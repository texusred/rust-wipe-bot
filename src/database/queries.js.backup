class DatabaseQueries {
    constructor(db) {
        this.db = db;
    }

    async addPlayer(discordId, username) {
        return new Promise((resolve, reject) => {
            const stmt = this.db.prepare(`
                INSERT OR REPLACE INTO players (discord_id, username) 
                VALUES (?, ?)
            `);
            stmt.run([discordId, username], function(err) {
                if (err) reject(err);
                else resolve(this.lastID);
            });
        });
    }

    async getAllPlayers() {
        return new Promise((resolve, reject) => {
            this.db.all(`
                SELECT * FROM players WHERE active = 1 
                ORDER BY username
            `, (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    // Get current week's cycle (this Friday's wipe)
    async getCurrentCycle() {
        return new Promise((resolve, reject) => {
            this.db.get(`
                SELECT * FROM wipe_cycles 
                WHERE status = 'current' 
                ORDER BY cycle_id DESC LIMIT 1
            `, (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
    }

    // Get next week's cycle (selection target)
    async getNextCycle() {
        return new Promise((resolve, reject) => {
            this.db.get(`
                SELECT * FROM wipe_cycles 
                WHERE status = 'upcoming' 
                ORDER BY cycle_id DESC LIMIT 1
            `, (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
    }

    async createNewCycle(startDate, endDate, status = 'upcoming') {
        return new Promise((resolve, reject) => {
            const stmt = this.db.prepare(`
                INSERT INTO wipe_cycles (start_date, end_date, status) 
                VALUES (?, ?, ?)
            `);
            stmt.run([startDate, endDate, status], function(err) {
                if (err) reject(err);
                else resolve(this.lastID);
            });
        });
    }

    // Advance cycles: upcoming -> current, create new upcoming
    async advanceCycles() {
        return new Promise((resolve, reject) => {
            this.db.serialize(() => {
                // Move current to completed
                this.db.run(`UPDATE wipe_cycles SET status = 'completed' WHERE status = 'current'`);
                
                // Move upcoming to current
                this.db.run(`UPDATE wipe_cycles SET status = 'current' WHERE status = 'upcoming'`);
                
                // Clear all interest expressions (reset for new cycle)
                this.db.run(`DELETE FROM interest_expressions`, (err) => {
                    if (err) reject(err);
                    else resolve();
                });
            });
        });
    }

    // Express interest for the NEXT selection (affects week after upcoming)
    async expressInterest(playerId) {
        return new Promise((resolve, reject) => {
            // Check if already expressed
            this.db.get(`
                SELECT id FROM interest_expressions WHERE player_id = ?
            `, [playerId], (err, row) => {
                if (err) reject(err);
                else if (row) {
                    reject(new Error('Interest already expressed for next selection'));
                } else {
                    const stmt = this.db.prepare(`
                        INSERT INTO interest_expressions (player_id) 
                        VALUES (?)
                    `);
                    stmt.run([playerId], function(err) {
                        if (err) reject(err);
                        else resolve(this.lastID);
                    });
                }
            });
        });
    }

    async hasExpressedInterest(playerId) {
        return new Promise((resolve, reject) => {
            this.db.get(`
                SELECT id FROM interest_expressions WHERE player_id = ?
            `, [playerId], (err, row) => {
                if (err) reject(err);
                else resolve(!!row);
            });
        });
    }

    async getInterestedPlayers() {
        return new Promise((resolve, reject) => {
            this.db.all(`
                SELECT p.discord_id, p.username 
                FROM players p
                JOIN interest_expressions ie ON p.discord_id = ie.player_id
            `, (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    async updateCycleSelection(cycleId, selectedPlayers) {
        return new Promise((resolve, reject) => {
            const stmt = this.db.prepare(`
                UPDATE wipe_cycles 
                SET selected_players = ? 
                WHERE cycle_id = ?
            `);
            stmt.run([JSON.stringify(selectedPlayers), cycleId], function(err) {
                if (err) reject(err);
                else resolve();
            });
        });
    }

    async getPlayerHistory(playerId, weeksBack = 6) {
        return new Promise((resolve, reject) => {
            this.db.all(`
                SELECT wc.start_date, ph.participated 
                FROM player_history ph
                JOIN wipe_cycles wc ON ph.cycle_id = wc.cycle_id
                WHERE ph.player_id = ? AND wc.start_date >= date('now', '-${weeksBack} weeks')
                ORDER BY wc.start_date DESC
            `, [playerId], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }
}

module.exports = DatabaseQueries;
